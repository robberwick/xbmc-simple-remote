
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module.exports) {
    module.exports = {};
    module.client = module.component = true;
    module.call(this, module.exports, require.relative(resolved), module);
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);
  var index = path + '/index.js';

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
  }

  if (require.aliases.hasOwnProperty(index)) {
    return require.aliases[index];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};

require.register("component-css/index.js", function(exports, require, module){

/**
 * Properties to ignore appending "px".
 */

var ignore = {
  columnCount: true,
  fillOpacity: true,
  fontWeight: true,
  lineHeight: true,
  opacity: true,
  orphans: true,
  widows: true,
  zIndex: true,
  zoom: true
};

/**
 * Set `el` css values.
 *
 * @param {Element} el
 * @param {Object} obj
 * @return {Element}
 * @api public
 */

module.exports = function(el, obj){
  for (var key in obj) {
    var val = obj[key];
    if ('number' == typeof val && !ignore[key]) val += 'px';
    el.style[key] = val;
  }
  return el;
};

});
require.register("niclashoyer-drawer/index.js", function(exports, require, module){
// Generated by CoffeeScript 1.6.2
(function() {
  var Drawer, addDrawerStyles, css;

  css = require('css');

  addDrawerStyles = function(drawer, direction) {
    var styles;

    styles = {};
    switch (direction) {
      case 'left':
        styles.left = 0;
        styles.right = 'auto';
        break;
      case 'right':
        styles.right = 0;
        styles.left = 'auto';
        break;
      case 'top':
        styles.top = 0;
        styles.bottom = 'auto';
        break;
      case 'bottom':
        styles.bottom = 0;
        styles.top = 'auto';
    }
    switch (direction) {
      case 'left':
      case 'right':
        styles.height = '100%';
        styles.maxHeight = 'none';
        styles.minHeight = 'none';
        break;
      case 'top':
      case 'bottom':
        styles.width = '100%';
        styles.maxWidth = 'none';
        styles.minWidth = 'none';
    }
    return css(drawer, styles);
  };

  Drawer = (function() {
    function Drawer(root, direction) {
      var first, second,
        _this = this;

      this.root = root;
      if (direction == null) {
        direction = 'vertical';
      }
      if (direction === 'vertical') {
        first = 'left';
        second = 'right';
        this.drawerProps = {
          size: 'width',
          change: 'left'
        };
      } else {
        first = 'top';
        second = 'bottom';
        this.drawerProps = {
          size: 'height',
          change: 'top'
        };
      }
      this._findElements(first, second);
      if (this.drawer1 != null) {
        addDrawerStyles(this.drawer1, first);
      }
      if (this.drawer2 != null) {
        addDrawerStyles(this.drawer2, second);
      }
      this.active = null;
      addEventListener('resize', function() {
        return _this.update();
      });
    }

    Drawer.prototype._findElements = function(first, second) {
      this.drawers = this.root.querySelector('.drawers');
      this.drawer1 = this.drawers.querySelector('.' + first);
      this.drawer2 = this.drawers.querySelector('.' + second);
      return this.content = this.root.querySelector('.content');
    };

    Drawer.prototype._getDrawerStyle = function(drawer, prefix) {
      var styles;

      if (prefix == null) {
        prefix = '';
      }
      styles = {};
      styles[this.drawerProps.change] = prefix + getComputedStyle(drawer)[this.drawerProps.size];
      return styles;
    };

    Drawer.prototype._draw = function(first, second, prefix) {
      if (first != null) {
        css(this.content, this._getDrawerStyle(first, prefix));
        if (second != null) {
          second.classList.remove('active');
        }
        first.classList.add('active');
        this.active = first;
        return this;
      }
    };

    Drawer.prototype.drawFirst = function() {
      return this._draw(this.drawer1, this.drawer2);
    };

    Drawer.prototype.drawSecond = function() {
      return this._draw(this.drawer2, this.drawer1, '-');
    };

    Drawer.prototype.close = function() {
      var _ref, _ref1;

      css(this.content, {
        left: 0,
        top: 0
      });
      if ((_ref = this.drawer1) != null) {
        _ref.classList.remove('active');
      }
      if ((_ref1 = this.drawer2) != null) {
        _ref1.classList.remove('active');
      }
      this.active = null;
      return this;
    };

    Drawer.prototype._toggle = function(first, second, prefix) {
      if (this.active === first) {
        return this.close();
      } else {
        return this._draw(first, second, prefix);
      }
    };

    Drawer.prototype.toggleFirst = function() {
      return this._toggle(this.drawer1, this.drawer2);
    };

    Drawer.prototype.toggleSecond = function() {
      return this._toggle(this.drawer2, this.drawer1, '-');
    };

    Drawer.prototype.update = function() {
      if (this.active !== null) {
        if (this.active === this.drawer1) {
          return this.drawFirst();
        } else {
          return this.drawSecond();
        }
      }
    };

    Drawer.prototype.drawLeft = Drawer.prototype.drawFirst;

    Drawer.prototype.drawRight = Drawer.prototype.drawSecond;

    Drawer.prototype.drawTop = Drawer.prototype.drawFirst;

    Drawer.prototype.drawBottom = Drawer.prototype.drawSecond;

    Drawer.prototype.toggleLeft = Drawer.prototype.toggleFirst;

    Drawer.prototype.toggleRight = Drawer.prototype.toggleSecond;

    Drawer.prototype.toggleTop = Drawer.prototype.toggleFirst;

    Drawer.prototype.toggleBottom = Drawer.prototype.toggleSecond;

    return Drawer;

  })();

  module.exports = Drawer;

}).call(this);

});
require.register("component-indexof/index.js", function(exports, require, module){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
});
require.register("component-emitter/index.js", function(exports, require, module){

/**
 * Module dependencies.
 */

var index = require('indexof');

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  fn._off = on;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var i = index(callbacks, fn._off || fn);
  if (~i) callbacks.splice(i, 1);
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

});
require.register("fisch42-xbmc-client/xbmc-client.js", function(exports, require, module){
// Generated by CoffeeScript 1.4.0
(function() {
  var Emitter, XbmcClient, buttons,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Emitter = require('emitter');

  buttons = {
    Player: ['PlayPause', 'Stop'],
    Input: ['Up', 'Down', 'Left', 'Right', 'Select', 'Back', 'Home']
  };

  XbmcClient = (function(_super) {
    var arr, button, method, _fn, _i, _len,
      _this = this;

    __extends(XbmcClient, _super);

    function XbmcClient(ip, port) {
      this.ip = ip;
      this.port = port;
      this.requests = {};
      this.id = 0;
      this.player = null;
      this.connect(this.ip, this.port);
      this.listen();
    }

    XbmcClient.prototype.connect = function(ip, port) {
      var _this = this;
      this.ws = new WebSocket('ws://' + ip + ':' + port + '/jsonrpc');
      return this.ws.addEventListener('open', function() {
        return _this.getActivePlayers();
      });
    };

    XbmcClient.prototype.sendRequest = function(data, cb) {
      this.id++;
      if (cb != null) {
        this.requests[this.id] = cb;
      }
      data.id = this.id;
      data.jsonrpc = '2.0';
      return this.ws.send(JSON.stringify(data));
    };

    XbmcClient.prototype.listen = function() {
      var _this = this;
      return this.ws.addEventListener('message', function(e) {
        var data, _ref, _ref1, _ref2;
        try {
          data = JSON.parse(e.data);
          if (data.result != null) {
            if (data.id !== void 0) {
              if (_this.requests[_this.id] !== void 0) {
                _this.requests[_this.id](data.result);
                delete _this.requests[_this.id];
              }
            }
          }
          switch (data.method) {
            case 'Player.OnPlay':
              _this.player = (_ref = data.params) != null ? (_ref1 = _ref.data) != null ? (_ref2 = _ref1.player) != null ? _ref2.playerid : void 0 : void 0 : void 0;
              return _this.emit('play');
            case 'Player.OnStop':
              _this.player = null;
              return _this.emit('stop');
            case 'Player.OnPause':
              return _this.emit('pause');
          }
        } catch (ex) {
          throw ex;
        }
      });
    };

    XbmcClient.prototype.getActivePlayers = function() {
      var _this = this;
      return this.sendRequest({
        method: 'Player.GetActivePlayers'
      }, function(data) {
        if (data.length > 0) {
          return _this.player = data[0].playerid;
        } else {
          return _this.player = null;
        }
      });
    };

    XbmcClient.prototype.sendPlayerRequest = function(data, cb) {
      if (data.params === void 0) {
        data.params = {};
      }
      if (this.player != null) {
        data.params.playerid = this.player;
      }
      return this.sendRequest(data, cb);
    };

    XbmcClient.prototype.sendPlayerButton = function(button, cb) {
      return this.sendPlayerRequest({
        method: 'Player.' + button
      }, cb);
    };

    XbmcClient.prototype.sendButton = function(method, button, cb) {
      return this.sendRequest({
        method: method + "." + button
      }, cb);
    };

    for (method in buttons) {
      arr = buttons[method];
      _fn = function(method, button) {
        var str;
        str = button.toLowerCase().substr(0, 1) + button.substr(1);
        return XbmcClient.prototype[str] = function(cb) {
          if (method === 'Player') {
            return this.sendPlayerButton(button, cb);
          } else {
            return this.sendButton(method, button, cb);
          }
        };
      };
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        button = arr[_i];
        _fn(method, button);
      }
    }

    return XbmcClient;

  }).call(this, Emitter);

  module.exports = XbmcClient;

}).call(this);

});

require.alias("niclashoyer-drawer/index.js", "xbmc-simple-remote/deps/drawer/index.js");
require.alias("niclashoyer-drawer/index.js", "xbmc-simple-remote/deps/drawer/index.js");
require.alias("niclashoyer-drawer/index.js", "drawer/index.js");
require.alias("component-css/index.js", "niclashoyer-drawer/deps/css/index.js");

require.alias("niclashoyer-drawer/index.js", "niclashoyer-drawer/index.js");

require.alias("fisch42-xbmc-client/xbmc-client.js", "xbmc-simple-remote/deps/xbmc-client/xbmc-client.js");
require.alias("fisch42-xbmc-client/xbmc-client.js", "xbmc-simple-remote/deps/xbmc-client/index.js");
require.alias("fisch42-xbmc-client/xbmc-client.js", "xbmc-client/index.js");
require.alias("component-emitter/index.js", "fisch42-xbmc-client/deps/emitter/index.js");
require.alias("component-indexof/index.js", "component-emitter/deps/indexof/index.js");

require.alias("fisch42-xbmc-client/xbmc-client.js", "fisch42-xbmc-client/index.js");

